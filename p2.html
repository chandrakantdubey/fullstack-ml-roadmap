<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project 2 Guide: Live Financial Market Data Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        h1, h2, h3, h4 {
            font-weight: 700;
        }
        pre {
            font-family: 'Source Code Pro', monospace;
            background-color: #1e293b; /* slate-800 */
            color: #e2e8f0; /* slate-200 */
            padding: 1.5rem;
            border-radius: 0.75rem;
            overflow-x: auto;
            font-size: 0.875rem;
        }
        code {
            font-family: 'Source Code Pro', monospace;
            background-color: #e2e8f0;
            color: #1e293b;
            padding: 0.1rem 0.3rem;
            border-radius: 0.25rem;
        }
        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
            border-radius: 0;
        }
        .step-number {
            background-color: #f59e0b; /* amber-500 */
            color: white;
            border-radius: 9999px;
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.25rem;
            flex-shrink: 0;
        }
        .pro-tip {
            background-color: #fffbeb; /* amber-50 */
            border-left: 4px solid #f59e0b; /* amber-500 */
            padding: 1rem;
            border-radius: 0.5rem;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">
    <div class="container mx-auto p-4 md:p-8 max-w-5xl">
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-bold text-slate-900 mb-2">Project 2: Live Financial Data Dashboard</h1>
            <p class="text-lg text-slate-600">An in-depth implementation guide for building a real-time WebSocket application.</p>
        </header>

        <main class="space-y-16">
            <!-- Section 1: Architecture & Data Flow -->
            <section>
                <h2 class="text-3xl font-bold border-b-2 border-amber-200 pb-2 mb-6">Architecture & Real-Time Data Flow</h2>
                <div class="space-y-4 text-slate-700 mb-8">
                    <p><strong>Project Goal:</strong> To build a service that ingests live financial data from a third-party API, streams it to multiple clients in real-time using WebSockets, and simultaneously performs server-side analysis to detect and broadcast anomaly alerts.</p>
                    <p><strong>Core Technologies:</strong></p>
                    <ul class="list-disc list-inside ml-4">
                        <li><strong>Backend:</strong> Python with FastAPI (specifically its WebSocket support)</li>
                        <li><strong>Frontend:</strong> A minimal Next.js application to act as the client.</li>
                        <li><strong>External Service:</strong> A financial data provider API (e.g., Alpha Vantage, Polygon.io).</li>
                        <li><strong>Containerization:</strong> Docker for the backend service.</li>
                    </ul>
                </div>

                <h3 class="text-2xl font-bold mb-4">System Flow Diagram</h3>
                <p class="mb-4 text-slate-700">This diagram shows the two parallel processes: clients connecting and the backend fetching and broadcasting data.</p>
                <pre><code class="language-text">
+-----------------+      +--------------------------------+      +--------------------+
|                 |      |                                |      |                    |
| Frontend Client |----->| FastAPI WebSocket Endpoint     |----->| Connection Manager |
| (Next.js)       | (1)  | (e.g., /ws)                    | (2)  | (Singleton Class)  |
|                 |      | - Accepts new connections      |      | - Stores active    |
+-----------------+      | - Handles disconnects          |      |   WebSockets       |
                       |                                |      |                    |
                       +--------------------------------+      +--------------------+
                                     ^                                  | (5) Broadcast
                                     | (4) Push data to Manager         |
                                     |                                  v
+-----------------+      +--------------------------------+      +--------------------+
|                 |      |                                |      | All Connected      |
| External FinAPI |<-----| Background Task (asyncio.Task) |      | Clients Receive    |
| (e.g., AlphaV)  | (3)  | - Polls API every X seconds    |      | Data & Alerts      |
|                 |      | - Performs anomaly detection   |      +--------------------+
+-----------------+      +--------------------------------+

(1) A client establishes a persistent WebSocket connection.
(2) The endpoint adds the new connection to the Connection Manager.
(3) An independent, asynchronous background task continuously fetches data from the external API.
(4) The background task analyzes the data and sends it (plus any alerts) to the Connection Manager.
(5) The Connection Manager iterates through all active connections and broadcasts the data.
                </code></pre>
            </section>

            <!-- Section 2: Backend Implementation Strategy -->
            <section>
                <h2 class="text-3xl font-bold border-b-2 border-amber-200 pb-2 mb-6">Backend Implementation Strategy (FastAPI)</h2>
                <div class="space-y-8">
                    <div class="flex items-start gap-4">
                        <div class="step-number">1</div>
                        <div>
                            <h3 class="text-xl font-semibold mb-1">WebSocket Connection Management</h3>
                            <p class="text-slate-700">A robust application needs to manage the state of all connected clients. The best practice is to create a singleton class, a `ConnectionManager`, to handle this. This class will maintain a list of active `WebSocket` objects.</p>
                            <p class="text-slate-700 mt-2">The manager should have methods to `connect(websocket)`, `disconnect(websocket)`, and `broadcast(message)`. The broadcast method will be asynchronous and will iterate through the list of connections, sending the message to each one.</p>
                            <pre><code class="language-python"># Snippet: connection_manager.py
class ConnectionManager:
    def __init__(self):
        self.active_connections: list[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def broadcast(self, message: str):
        for connection in self.active_connections:
            await connection.send_text(message)
</code></pre>
                        </div>
                    </div>

                    <div class="flex items-start gap-4">
                        <div class="step-number">2</div>
                        <div>
                            <h3 class="text-xl font-semibold mb-1">Asynchronous Background Task for Data Fetching</h3>
                            <p class="text-slate-700">Polling the external financial API should not block the main application or depend on incoming requests. This is a perfect use case for an `asyncio` background task. This task will run in an infinite loop (`while True:`), fetch data, perform analysis, broadcast, and then `await asyncio.sleep(POLL_INTERVAL)` before repeating.</p>
                            <p class="text-slate-700 mt-2">This task should be started when the FastAPI application boots up using a lifespan event handler (`@asynccontextmanager`).</p>
                        </div>
                    </div>

                    <div class="flex items-start gap-4">
                        <div class="step-number">3</div>
                        <div>
                            <h3 class="text-xl font-semibold mb-1">Implementing the WebSocket Endpoint</h3>
                            <p class="text-slate-700">The endpoint itself is relatively simple. It uses the `@app.websocket("/ws")` decorator. Its main job is to accept a connection, add it to the `ConnectionManager`, and then wait in a `try...finally` block. The `finally` block ensures that if the client disconnects for any reason (closing the tab, network error), the `manager.disconnect()` method is called to clean up the connection.</p>
                            <pre><code class="language-python"># Snippet: main.py
manager = ConnectionManager()

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            # Keep the connection alive
            await websocket.receive_text()
    except WebSocketDisconnect:
        manager.disconnect(websocket)
</code></pre>
                        </div>
                    </div>

                    <div class="flex items-start gap-4">
                        <div class="step-number">4</div>
                        <div>
                            <h3 class="text-xl font-semibold mb-1">Server-Side Anomaly Detection</h3>
                            <p class="text-slate-700">Inside the background task's loop, after fetching new data, implement the analysis logic. A simple but effective method is to maintain a rolling window of the last N data points (e.g., the last 20 prices). For each new data point, calculate the moving average and standard deviation of this window. If the new price is more than a certain number of standard deviations (e.g., 2 or 3) away from the moving average, it's an anomaly. You would then broadcast both the price data and a separate "alert" message.</p>
                        </div>
                    </div>
                </div>
            </section>

             <!-- Section 3: Frontend Implementation Strategy -->
            <section>
                <h2 class="text-3xl font-bold border-b-2 border-amber-200 pb-2 mb-6">Frontend Implementation Strategy (Next.js)</h2>
                <div class="space-y-8">
                    <div class="flex items-start gap-4">
                        <div class="step-number">1</div>
                        <div>
                            <h3 class="text-xl font-semibold mb-1">Establishing and Managing the Connection</h3>
                            <p class="text-slate-700">Use a React `useEffect` hook with an empty dependency array `[]` to establish the WebSocket connection when the component mounts. The browser's native `new WebSocket("ws://localhost:8000/ws")` is sufficient. It's crucial to also return a cleanup function from this `useEffect` that calls `socket.close()` to gracefully terminate the connection when the component unmounts.</p>
                        </div>
                    </div>
                     <div class="flex items-start gap-4">
                        <div class="step-number">2</div>
                        <div>
                            <h3 class="text-xl font-semibold mb-1">Handling Incoming Messages</h3>
                            <p class="text-slate-700">Inside the `useEffect`, set up the `socket.onmessage` event handler. This function will be triggered every time the server broadcasts data. The data will arrive as a JSON string, so you'll need to `JSON.parse(event.data)`. You can then use this parsed object to update your component's state (e.g., `setData(newData)`).</p>
                             <div class="pro-tip mt-4">
                                <p><strong>State Management:</strong> For a simple list of incoming prices, you might want to keep an array of the last 50-100 data points in state to avoid the list growing indefinitely and causing performance issues. You can manage this by taking a slice of the previous state array and appending the new data.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>
</body>
</html>
