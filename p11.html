<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Project 11 Guide: Social Media Analytics Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://css2?family=Inter:wght@400;500;600;700&family=Source+Code+Pro:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
      }
      h1,
      h2,
      h3,
      h4 {
        font-weight: 700;
      }
      pre {
        font-family: "Source Code Pro", monospace;
        background-color: #1e293b; /* slate-800 */
        color: #e2e8f0; /* slate-200 */
        padding: 1.5rem;
        border-radius: 0.75rem;
        overflow-x: auto;
        font-size: 0.875rem;
      }
      code {
        font-family: "Source Code Pro", monospace;
        background-color: #e2e8f0;
        color: #1e293b;
        padding: 0.1rem 0.3rem;
        border-radius: 0.25rem;
      }
      pre code {
        background-color: transparent;
        color: inherit;
        padding: 0;
        border-radius: 0;
      }
      .step-number {
        background-color: #f59e0b; /* amber-500 */
        color: white;
        border-radius: 9999px;
        width: 2.5rem;
        height: 2.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        font-size: 1.25rem;
        flex-shrink: 0;
      }
      .pro-tip {
        background-color: #fffbeb; /* amber-50 */
        border-left: 4px solid #f59e0b; /* amber-500 */
        padding: 1rem;
        border-radius: 0.5rem;
      }
    </style>
  </head>
  <body class="bg-slate-50 text-slate-800">
    <div class="container mx-auto p-4 md:p-8 max-w-5xl">
      <header class="text-center mb-12">
        <h1 class="text-4xl md:text-5xl font-bold text-slate-900 mb-2">
          Project 11: Social Media Analytics Dashboard
        </h1>
        <p class="text-lg text-slate-600">
          A guide to building a high-throughput, real-time data processing and
          visualization pipeline.
        </p>
      </header>

      <main class="space-y-16">
        <!-- Section 1: Architecture & Core Concepts -->
        <section>
          <h2 class="text-3xl font-bold border-b-2 border-amber-200 pb-2 mb-6">
            Real-Time Data Pipeline Architecture
          </h2>
          <div class="space-y-4 text-slate-700 mb-8">
            <p>
              <strong>Project Goal:</strong> To design and build a complete,
              end-to-end system for ingesting, processing, storing, and
              visualizing high-volume, time-sensitive data. This project is a
              practical application of advanced system design principles,
              forcing a shift in thinking from simple CRUD applications to
              scalable data pipelines.
            </p>
            <p><strong>Core Technologies & Packages:</strong></p>
            <ul class="list-disc list-inside ml-4">
              <li>
                <strong>Data Ingestion:</strong> FastAPI (for its high
                performance)
              </li>
              <li><strong>Processing Queue:</strong> RabbitMQ</li>
              <li><strong>Analytics API:</strong> NestJS</li>
              <li>
                <strong>Real-Time Frontend:</strong> Next.js with WebSockets
              </li>
              <li>
                <strong>Time-Series Database:</strong> TimescaleDB (as a
                PostgreSQL extension)
              </li>
            </ul>
          </div>

          <h3 class="text-2xl font-bold mb-4">End-to-End System Diagram</h3>
          <p class="mb-4 text-slate-700">
            This diagram shows the complete journey of a single piece of data
            from ingestion to its appearance on the real-time dashboard.
          </p>
          <pre><code class="language-text">
+---------------+   +----------------+   +----------------+   +-----------------+   +--------------------+
| Data Source   |-->| FastAPI        |-->| RabbitMQ       |-->| Processing      |-->| Sentiment Analysis |
| (Simulator)   |(1)| Ingestion EP   |(2)| (Message Queue)|(3)| Worker (NestJS) |(4)| API (Project 3)    |
+---------------+   +----------------+   +----------------+   +-----------------+   +--------------------+
                                                                     |
                                                                     | (5) Enriched Data
                                                                     v
+--------------------------------------------------------------------+-------------------------------------------+
|                                                                    |                                           |
| (6a) Aggregation Logic                                             | (6b) Real-Time Path                       |
| - Groups by time window                                            v                                           |
| - Calculates metrics                                     +-----------------+                                   |
|      |                                                     | Analytics API   |                                   |
|      | (7a)                                                | (NestJS)        |                                   |
|      v                                                     +-------+---------+                                   |
| +--------------------+                                             | (7b)                                        |
| | TimescaleDB        | &lt;--(8)---------------------------------------+                                           |
| | (Time-Series Data) |                                             | (7c) WebSocket Broadcast                  |
| +--------------------+                                             v                                           |
|                                                              +-----------------+                               |
|                                                              | Next.js         |                               |
|                                                              | Dashboard       |                               |
|                                                              +-----------------+                               |
+------------------------------------------------------------------------------------------------------------------+
                </code></pre>
        </section>

        <!-- Section 2: Implementation Strategy -->
        <section>
          <h2 class="text-3xl font-bold border-b-2 border-amber-200 pb-2 mb-6">
            Implementation Strategy
          </h2>
          <div class="space-y-8">
            <div class="flex items-start gap-4">
              <div class="step-number">1</div>
              <div>
                <h3 class="text-xl font-semibold mb-1">
                  System Design First: Whiteboarding the Pipeline
                </h3>
                <p class="text-slate-700">
                  Before writing any code, the entire system must be designed.
                  This is a critical senior-level skill. The process involves
                  identifying each component's responsibility and defining the
                  "data contracts" between them. Key questions to answer are:
                </p>
                <ul
                  class="list-disc list-inside ml-4 text-slate-700 space-y-2 mt-2"
                >
                  <li>
                    <strong>Ingestion:</strong> How do we handle massive bursts
                    of incoming data without dropping requests? (Answer: A
                    high-performance async framework like FastAPI and a message
                    queue).
                  </li>
                  <li>
                    <strong>Processing:</strong> How do we perform potentially
                    slow operations (like calling an external AI API) without
                    blocking the ingestion layer? (Answer: Decoupled worker
                    processes consuming from the queue).
                  </li>
                  <li>
                    <strong>Storage:</strong> How do we efficiently store and
                    query data based on time? (Answer: A specialized time-series
                    database).
                  </li>
                  <li>
                    <strong>Visualization:</strong> How do we push real-time
                    updates to the client? (Answer: WebSockets).
                  </li>
                </ul>
              </div>
            </div>

            <div class="flex items-start gap-4">
              <div class="step-number">2</div>
              <div>
                <h3 class="text-xl font-semibold mb-1">
                  Building the High-Throughput Ingestion Service
                </h3>
                <p class="text-slate-700">
                  You will build a minimal but extremely fast FastAPI service.
                  Its sole responsibility is to accept incoming POST requests,
                  perform basic validation with Pydantic, and immediately
                  publish the raw data to a RabbitMQ queue. It does **no other
                  processing**. This "fire and forget" approach ensures the
                  endpoint can handle a very high number of concurrent requests
                  with minimal latency.
                </p>
              </div>
            </div>

            <div class="flex items-start gap-4">
              <div class="step-number">3</div>
              <div>
                <h3 class="text-xl font-semibold mb-1">
                  The Asynchronous Processing Worker
                </h3>
                <p class="text-slate-700">
                  A separate NestJS application will be created to act as the
                  processing worker. This application will not have any HTTP
                  endpoints. Instead, it will connect to RabbitMQ and listen for
                  messages on the queue. For each message, it will:
                </p>
                <ol
                  class="list-decimal list-inside ml-4 text-slate-700 space-y-2 mt-2"
                >
                  <li>
                    Filter the post to see if it contains a tracked brand
                    mention.
                  </li>
                  <li>
                    If it does, make an HTTP call to the Sentiment Analysis API
                    (from Project 3) to get the sentiment.
                  </li>
                  <li>
                    The enriched data (original post + sentiment) is then ready
                    for the next stage.
                  </li>
                </ol>
              </div>
            </div>

            <div class="flex items-start gap-4">
              <div class="step-number">4</div>
              <div>
                <h3 class="text-xl font-semibold mb-1">
                  Implementing the Time-Series Database (TimescaleDB)
                </h3>
                <p class="text-slate-700">
                  You will add the TimescaleDB extension to a PostgreSQL
                  instance in your `docker-compose.yml`. The key is to design
                  the schema for time-series data. You will create a table for
                  the processed mentions and then convert it into a
                  **hypertable**, which is TimescaleDB's core feature. This
                  automatically partitions the data by time, making queries that
                  filter or aggregate by a time range (e.g., "mentions per
                  minute over the last hour") incredibly fast.
                </p>
                <div class="pro-tip mt-4">
                  <p>
                    <strong>Continuous Aggregates:</strong> To further optimize
                    the dashboard, you will implement a "continuous aggregate."
                    This is a materialized view that automatically and
                    efficiently computes aggregate data (like counts and average
                    sentiment per minute) in the background. Your analytics API
                    will query this much smaller, pre-calculated table instead
                    of the raw data, resulting in near-instant dashboard load
                    times.
                  </p>
                </div>
              </div>
            </div>

            <div class="flex items-start gap-4">
              <div class="step-number">5</div>
              <div>
                <h3 class="text-xl font-semibold mb-1">
                  The Analytics API and Real-Time Dashboard
                </h3>
                <p class="text-slate-700">
                  A third NestJS application will serve as the Analytics API. It
                  will have two primary functions:
                </p>
                <ul
                  class="list-disc list-inside ml-4 text-slate-700 space-y-2 mt-2"
                >
                  <li>
                    <strong>HTTP Endpoints:</strong> Provide historical data by
                    querying the continuous aggregate views in TimescaleDB. This
                    is used to populate the dashboard when it first loads.
                  </li>
                  <li>
                    <strong>WebSocket Gateway:</strong> The processing worker,
                    after saving data to the database, will also send the
                    enriched data to this Analytics API (e.g., via another
                    RabbitMQ message). The API's WebSocket gateway will then
                    immediately broadcast this new data point to all connected
                    dashboard clients, allowing for live updates without
                    requiring the client to poll for changes.
                  </li>
                </ul>
                <p class="text-slate-700 mt-2">
                  The Next.js frontend will use a charting library to visualize
                  the historical data and will listen on the WebSocket
                  connection to append new data points to the charts in real
                  time.
                </p>
              </div>
            </div>
          </div>
        </section>
      </main>
    </div>
  </body>
</html>
